0. Review
0.1. Casting
up Casting : 자식 값을 부모타입으로 형 변환 해주는 것.
down Casting : up Casting 된 객체를 다시 자식 타입으로 형 변환 해주는 것.
※부모값을 자식의 타입으로 형 변환시 오류가 발생한다.
※자식클래스 타입의 객체는 부모클래스 타입도 동시에 가진다.

0.2. 객체 간 타입비교
객체 instanceof 클래스명
객체가 클래스 타입이면 true, 객체가 클래스 타입이 아니라면 false가 반환된다.

0.3. 다형성 : 하나의 것이 여러가지 형태를 가질 수 있는 성질
   1) 오버로딩
   2) 오버라이딩
   3) 참조변수의 다형성

1. 추상클래스
메소드
리턴타입 메소드명(자료형 매개변수)//선언부
{//실행할 코드
//return 리턴값;}//추상 클래스는 이러한 구현부가 없는 클래스이다.

리턴타입 메소드명(자료형 매개변수);//까지만 구현하고 끝난다.

추상메소드 : 메소드를 선언만하고 구현을 하지 않은 것.(미완성된 메소드)

추상클래스 : abstract 키워드가 붙은 클래스
추상 메소드가 한개 이상있는 클래스는 반드시 추상클래스로 선언해야한다.(미완성된 클래스)

추상클래스 선언하기
abstract class 클래스명{
abstract 리턴타입 메소드명(자료형 매개변수);
//일반 메소드도 선언가능}
1) abstract 키워드를 사용한다
2) 객체화를 시킬 수 없다.
※미완성된 메소드(추상메소드)는 상속받은 자식 클래스에서 반드시 재정의하여 구현을 해야만 해당 클래스를 객체화 할 수 있다.
→ 강제성을 부여하기 위해서 추상 메소드로 선언한다.

추상클래스를 사용하는 이유?
- 공통되는 속성과 행위를 추상화하여 부모클래스를 만드는데 반드시 모든 자식클래스에서 구현해야하는 메소드가 있다면 추상클래스로 선언하는 것이 좋음.
- 추상 클래스를 상속받은 자식 클래스는 추상메소드를 오버라이딩 하지 않으면 오류가 발생하므로 ★강제성★ 생기게된다.
- 만약 부모클래스에서 메소드를 모두 구현하게되면 강제성이 사라지므로 자식클래스를 만드는 사람이 재정의하지 않고 그냥 넘어갈 수 있다.

2. Interface(인터페이스)
일종의 추상 클래스이지만 클래스라고부르지 않음 추상화의 정도가 높음 → 강제성
멤버로는 상수와 추상메소드만 가질 수 있다.
인터페이스는 객체화 할 수 없으며 다른클래스에서 구현(implements)해서 사용한다.
인터페이스의 선언
   interface 인터페이스명{
      //멤버(상수, 추상메소드)

   }

2.1. 인터페이스의 멤버
1) 모든 변수는 pubic static final이다(생략해도 자동으로 붙음) → 상수
2) 모든 메소드는 public abstract이다(생략해도 자동으로 붙음) → 추상메소드

2.2. 클래스 상속과 인터페이스의 구현
1) 클래스는 단일 상속만 가능하며 인터페이스는 다중구현이 가능하다.
2) 이넡페이스는 인터페이스를 상속할 수 있다.
3) 상속과 구현은 별개이다. → 하나의 클래스에 상속과 구현을 동시에 할 수 있다.

2.3. 인터페이스를 사용하는 이유
1) 여러 클래스에서 선언할 멤버들을 일관되게 하기 위해 사용한다(표준화)
2) 관계없는 클래스들을 그룹화시킬 수 있다.(마커 인터페이스)

2.4. 인터페이스의 불편함
- 인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는 것이 불가능하다.
이를 해결하기 위해 Adapter라는 추상 클래스를 활용한다.

2.5. Adapter클래스와 인터페이스
강제성을 완화하기위해 사용한다.
추상클래스로 만들기 때문에 미구현된 메소드와 구현된 메소드가 동시에 존재할 수 있다.
→그러므로 인터페이스를 상속받아 강제성을 없애고싶은 메소드만 재정의해준다.
이후 어댑터 클래스를 상속받는 자식 클래스는 내가 원하는메소드만 재정의할 수 있게 된다.
이때 어댑터 클래스의 이름은 이름앞에 Adapter를 붙여주어 목적을 알려주는 것이 좋음.

인터페이스(모든강제성)---일부구현-->추상클래스(일부강제성)---상속-->클래스
