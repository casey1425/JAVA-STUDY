0. Review
for, while, do~while은 어떻게 구별하나?
1) 반복횟수가 지정되는 경우 -> 횟수를 만족할때까지 반복
물통에 물을 10번 채워라 -> for
2) 특정 조건이 부여된 경우 -> 조건이 만족할때까지 반복
물통에 물이 가득찰때까지 채워라 -> while
3) 특정 조건과 옵션이 부여된경우 -> 한번 실행한 후 반복여부 판단
물통에 물을 따라보고 새지 않으면 끝까지 채워라 -> do~while 

1. Array(배열)

배열 : 저장공간의 나열
변수 : 하나의 자료형으로 하나의 값만 저장할 수 있는 저장공간
변수를 여러개 선언하면 이름이 여러개 생김 -> 각 저장공간을 관리하기가 불편해짐
1) n칸짜리 배열을 선언하면 저장공간이 여러개 생기고, 이름은 한개가 생김 -> 관리하기가 편해짐
2) 규칙성이 없는 값에 규칙성을 부여하기 위해서(index)

변수 : 하나의 타입으로 된 하나의 값만 저장할 수 있는 저장공간
배열 : 하나의 타입으로 된 여러개의 값을 저장할 수 있는 저장공간의 나열

1.1. 배열의 선언
1) 배열 변수를 선언 후 초기값 할당 : 어떤 값을 넣을지 알때 사용
	자료형[] 배열명={값1,값2...};
2) 배열 변수를 선언 후 배열 생성 : 어떤 값을 넣을지 모르지만 몇 칸 만들지는 알때 사용
	자료형[] 배열명=new 자료형[배열크기];
3) 배열 변수 선언 후 배열생성과 초기화
	자료형[] 배열명;
	배열명=new 자료형[]{값1, 값2...};
4) 배열을 생성하지 않고 배열 변수를 초기화 : 어떤 값을 넣을지도 모르고 몇 칸 만들지도 모를때
	자료형[] 배열명=null;

new : Heap메모리 할당, 저장공간의 시작주소를 가져옴
null : 주소의 초기값(어떤 주소가 들어갈지 모를때 사용)
Runtime Data Area : JVM이 프로그램을 실행하는동안 사용하는 메모리 영역
=> 힙영역, 메소드영역, 스택영역, 프로그램 카운터 레지스터, 네이티브 메소드 스택..

Heap Area(힙영역)
배열, 객체가 생성되는 메모리의 공간
new 연산자로 생성되며 동적 메모리 할당을 사용하기 때문에 프로그램 실행중에 메모리의 크기를 동적으로 조절할 수 있다.

Stack Area(스택영역)
메소드 호출시에 사용되는 메모리의 공간
메소드가 호출될때마다 스택에 새로운 프레임이 생성되며, 메소드 종료시에 해당 프레임이 제거된다.

Method Area(메소드영역)
클래스의 정보, static변수, 상수 등이 저장되는 메모리 공간
메소드 영역은 JVM이 시작할떄 생성된다.

Index : 배열을 생성할때 각각의 저장공간에 자동으로 붙여지는 번호
0부터 순차적으로 증가하면서 부여됨
배열의 이름은 한개이기 때문에 배열의 여러 저장공간에 접근할 수 없다.
배열명[index]로 사용하고 이는 하나의 저장공간이므로 변수처럼 사용한다.

1.2. 배열의 구조
int[]arData={1,3,5,7,9};
참조변수 : 배열 객체의 주소값을 가리킴
[] : 배열의 주소를 저장할 수 있음을 나타내는 기호

syso(arData) : 배열의 시작주소를 print
syso(arData[1]) : 1에 위치한 값을 print 

length
배열을 생성할때 자동으로 생성되는 저장공간의 수(배열의 길이)
배열의 길이는 한번 만들어지면 변동될 수 없으므로 length는 상수라고 볼 수 있다
배열명.length로 사용된다

1.3. 배열의 사용
배열명[인덱스] 사용할 수 있는데 이때 저장공간으로 활용되는지, 값으로 사용되는지를 잘 파악해야한다.

int[]arData={3,4,5,6,7};
arData[0]=10;//저장공간
arData[2]+5;//값
arData[4]+10;//error(index가 3까지만 존재)
arData[2]=arData[1]+arData[2]//저장공간=값+값
int num=arData[3];//값, 여기선 num에 6이 저장됨.

1.4. for each문(빠른 for문, 확장 for문)
배열이나 컬렉션을 순회할때 사용하는 반복문
요소의 타입과 변수명만을 지정하여 편하게 순회 가능
for(요소의 타입 변수명 : 배열 또는 컬렉션){
      요소에 대한 작업 수행
	}
	for(int i : arData){
	syso(i);
	}
배열 또는 컬렉션의 모든 요소를 차례대로 접근
요소를 수정할 수는 없음(읽기전용이다)
index사용 불가능
요소의 타입은 배열 또는 컬렉션의 타입과 일치해야한다.

1.5. 2차원배열
배열안의 배열
※2차원 이상의 배열은 메모리 낭비가 심하므로 선호하지 않음

2차원 배열의 선언
자료형[][]배열명=new자료형[행][열];
자료형[][]배열명={{값1,값2,...}, {값3,값4,...}}