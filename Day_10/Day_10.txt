0. Review
0.1. equals() 메소드
- 객체의 내용을 비교하기 위해서 사용하는 메소드
- 객체의 내용이 동일하면 true를 반환하고, 내용이 다르면 false를 반환한다.
- 문자열 내용을 비교할때 equals()메소드를 사용한다.

0.2. ==연산자
- 객체의 참조를 비교할때 사용한다
- 두 객체가 메모리에서 동일한 위치(같은 객체 참조)를 가리키는 경우에만 true를 반환하고 그렇지 않다면 false를 반환한다.
- 두 객체가 서로 다른 메모리 위치에 저장되어 있더라도 내용이 동일하다고 간주하지 않는다.

0.3. Class(클래스)
-사용자 정의 타입이다(자료형)
클래스를 사용하면 여러 타입, 여러 값을 저장할 수 있는 저장공간을 만들 수 있다.
클래스 안에 선언된 필드(변수)를 사용하고 싶다면 해당 클래스 타입으로 변수를 선언해야한다.
+) 배열의 한계 : 여러값을 저장할 수 있으나 하나의 타입만 저장 가능하다.

-연관성있는 저장공간과 기능을 한 곳에 모아 편하게 관리할 수 있는 것
저장공간과 기능을 나누어 관리하게 되면 코드가 길어졌을 때 사용하기 불편하다.
이때 연관되는 저장공간과 기능을 클래스로 묶어서 관리할 수 있다.

- 객체를 생성하기 위한 틀, 설계도
공통되는 속성(변수)과 행위(메소드)를 한 번만 선언해놓고 가져다 사용만 하도록 설계한다.
추상적인 것(클래스)을 구체화 시키면(메모리에 생성된 것)객체라고 한다.

-객체(Object)와 인스턴스(Instance)
클래스 : 실제 사물 또는 개념
객체 : 실제 사물 또는 개념
인스턴스 : 클래스를 메모리에 할당시킨 것이며 물리적으로 존재하는 공간(구체적임)
객체는 인스턴스보다 큰 범주이다.
일반적으로 객체와 인스턴스는 동일하다고 생각하고 사용해도 문제가 없다.
국내에서는 클래스와의 관계를 말할때 인스턴스라고 부른다고 알려져있다.

-클래스 선언
class 클래스명{
	변수;//멤버변수, 필드, 전역변수
	메소드(){}//멤버 메소드
	//class를 구성하는 모든 변수, 메소드를 합쳐서 멤버라고 부른다.
}

-Instantination(객체화)
객체를 만드는 작업, 추상적인 개념을 구체화 시키는 작업
클래스명 객체명=new 클래스명();
클래스명 참조변수명=new 생성자();

-객체 사용방법
참조변수명.필드명=값;
참조변수명.메소드명();
.(마침표) : 하위 연산자 멤버접근 연산자, 닷 연산자

-객체가 만들어지는 과정(메모리)
public void meMethod(){
	 MyClass		refVar		=new MyClass();
   자료형(클래스타입)     참조변수		new 생성자();
}
1. refVar라는 참조변수는 meMethod()라는 메소드 영역에서 만들어진 지역변수이므로 JVM이 관리하는 메모리의 stack영역에 생성된다.
2. new 연산자가 Heap 메모리에 MyClass 객체를 생성하고 참조값을 가져온다(참조값 반환) -> 이 때 생성자가 실행된다
3. 대입연산자를 통해 오른쪽에 참조값을 왼쪽의 참조변수에 저장한다

-생성자
클래스명 뒤에 소괄호가 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않는다.
생성자는 리턴이라는 기능이 존재하지 않는다.
1) 객체를 생성할 때 실행되는 코드가 작성되어있다.
2) 주로 해당 클래스의 필드(멤버변수)를 초기화하는 목적으로 사용한다.
→ 생성자를 사용하면 객체를 만듦과 동시에 내가 원하는 값으로 초기화 할 수 있다.

-기본생성자
public 클래스명(){}
매개변수가 없다.
클래스 선언시 자동으로 선언되며, 사용자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다.

2. Polymorphism(다형성)
하나의 것이 여러형태를 가질 수 있는 성질
객체지향언어에서 매우 중요한 특징!!

-메소드 오버로딩 : 매개변수의 타입, 개수, 순서가 다르면 같은 이름의 메소드로 선언할 수 있다. 반환타입은 오버로딩에 영향을 주지 않는다.
-생성자 오버로딩 : 매개변수의 타입, 개수, 순서가 다르면 같은 이름의 생성자를 선언할 수 있다. 객체의 초기값을 저장할떄 편리하게 사용가능하다.

this()
자기자신의 생성자를 의미한다
생성자 내부에서만 사용이 가능하며 최상단에 작성해야한다.
→생성자 내부에서 나의 다른 생성자를 호출할때 사용한다.